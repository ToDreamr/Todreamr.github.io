<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>要求熟记 on 春江花朝秋月夜</title>
    <link>/tags/%E8%A6%81%E6%B1%82%E7%86%9F%E8%AE%B0/</link>
    <description>Recent content in 要求熟记 on 春江花朝秋月夜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>© 2024 春江花朝秋月夜</copyright>
    <lastBuildDate>Mon, 18 Mar 2024 18:23:23 +0800</lastBuildDate><atom:link href="/tags/%E8%A6%81%E6%B1%82%E7%86%9F%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>抽象数据类型ADT</title>
      <link>/entire-note/%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%91/</link>
      <pubDate>Mon, 18 Mar 2024 18:23:23 +0800</pubDate>
      
      <guid>/entire-note/%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%91/</guid>
      <description>链表 ，队列和二叉树 #尝试使用cpp实现二叉树，下面是粗劣的代码： #指针和引用传递的区别：
//如果传递引用： void List_Init(List &amp;amp;list) { // 防止访问空指针 if (list.next != NULL) { list.next = NULL; list.node_count = 0; } } //如果传递指针： void List_Init(List *list) { // 防止访问空指针 if (list-&amp;gt;next !</description>
      
    </item>
    
    <item>
      <title>计算机科学基础</title>
      <link>/entire-note/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Sat, 09 Mar 2024 18:23:23 +0800</pubDate>
      
      <guid>/entire-note/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95/</guid>
      <description>基础知识 #Hash是什么，有哪些常见的hash定址法 #散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素 ，因而必 须要在数据元素的存储位置和它的关键字（可用 key 表示）之间建立一个确定的对应关系，使每个 关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定 关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。
1）直接定址法： 取关键字或关键字的某个线性函数值为散列地址。 即：h(key) = key 或 h(key) = a * key + b，其中 a 和 b 为常数。 （2）数字分析法 （3）平方取值法： 取关键字平方后的中间几位为散列地址。 （4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。 （5）除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址， 即：h(key) = key MOD p p ≤ m （6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址， 即：h(key) = random(key) 什么是排序二叉树 #首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值 大于它的根节点值，则这样的二叉树就是排序二叉树</description>
      <media:content xmlns:media="http://search.yahoo.com/mrss/" url="/entire-note/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95/featured.png" />
    </item>
    
  </channel>
</rss>
